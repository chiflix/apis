// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/api/metric.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines a metric type and its schema. Once a metric descriptor is created,
/// deleting or altering it stops data collection and makes the metric type's
/// existing data unusable.
public struct Google_Api_MetricDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the metric descriptor.
  public var name: String = String()

  /// The metric type, including its DNS name prefix. The type is not
  /// URL-encoded.  All user-defined custom metric types have the DNS name
  /// `custom.googleapis.com`.  Metric types should use a natural hierarchical
  /// grouping. For example:
  ///
  ///     "custom.googleapis.com/invoice/paid/amount"
  ///     "appengine.googleapis.com/http/server/response_latencies"
  public var type: String = String()

  /// The set of labels that can be used to describe a specific
  /// instance of this metric type. For example, the
  /// `appengine.googleapis.com/http/server/response_latencies` metric
  /// type has a label for the HTTP response code, `response_code`, so
  /// you can look at latencies for successful responses or just
  /// for responses that failed.
  public var labels: [Google_Api_LabelDescriptor] = []

  /// Whether the metric records instantaneous values, changes to a value, etc.
  /// Some combinations of `metric_kind` and `value_type` might not be supported.
  public var metricKind: Google_Api_MetricDescriptor.MetricKind = .unspecified

  /// Whether the measurement is an integer, a floating-point number, etc.
  /// Some combinations of `metric_kind` and `value_type` might not be supported.
  public var valueType: Google_Api_MetricDescriptor.ValueType = .unspecified

  /// The unit in which the metric value is reported. It is only applicable
  /// if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The
  /// supported units are a subset of [The Unified Code for Units of
  /// Measure](http://unitsofmeasure.org/ucum.html) standard:
  ///
  /// **Basic units (UNIT)**
  ///
  /// * `bit`   bit
  /// * `By`    byte
  /// * `s`     second
  /// * `min`   minute
  /// * `h`     hour
  /// * `d`     day
  ///
  /// **Prefixes (PREFIX)**
  ///
  /// * `k`     kilo    (10**3)
  /// * `M`     mega    (10**6)
  /// * `G`     giga    (10**9)
  /// * `T`     tera    (10**12)
  /// * `P`     peta    (10**15)
  /// * `E`     exa     (10**18)
  /// * `Z`     zetta   (10**21)
  /// * `Y`     yotta   (10**24)
  /// * `m`     milli   (10**-3)
  /// * `u`     micro   (10**-6)
  /// * `n`     nano    (10**-9)
  /// * `p`     pico    (10**-12)
  /// * `f`     femto   (10**-15)
  /// * `a`     atto    (10**-18)
  /// * `z`     zepto   (10**-21)
  /// * `y`     yocto   (10**-24)
  /// * `Ki`    kibi    (2**10)
  /// * `Mi`    mebi    (2**20)
  /// * `Gi`    gibi    (2**30)
  /// * `Ti`    tebi    (2**40)
  ///
  /// **Grammar**
  ///
  /// The grammar also includes these connectors:
  ///
  /// * `/`    division (as an infix operator, e.g. `1/s`).
  /// * `.`    multiplication (as an infix operator, e.g. `GBy.d`)
  ///
  /// The grammar for a unit is as follows:
  ///
  ///     Expression = Component { "." Component } { "/" Component } ;
  ///
  ///     Component = ( [ PREFIX ] UNIT | "%" ) [ Annotation ]
  ///               | Annotation
  ///               | "1"
  ///               ;
  ///
  ///     Annotation = "{" NAME "}" ;
  ///
  /// Notes:
  ///
  /// * `Annotation` is just a comment if it follows a `UNIT` and is
  ///    equivalent to `1` if it is used alone. For examples,
  ///    `{requests}/s == 1/s`, `By{transmitted}/s == By/s`.
  /// * `NAME` is a sequence of non-blank printable ASCII characters not
  ///    containing '{' or '}'.
  /// * `1` represents dimensionless value 1, such as in `1/s`.
  /// * `%` represents dimensionless value 1/100, and annotates values giving
  ///    a percentage.
  public var unit: String = String()

  /// A detailed description of the metric, which can be used in documentation.
  public var description_p: String = String()

  /// A concise name for the metric, which can be displayed in user interfaces.
  /// Use sentence case without an ending period, for example "Request count".
  /// This field is optional but it is recommended to be set for any metrics
  /// associated with user-visible concepts, such as Quota.
  public var displayName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The kind of measurement. It describes how the data is reported.
  public enum MetricKind: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Do not use this default value.
    case unspecified // = 0

    /// An instantaneous measurement of a value.
    case gauge // = 1

    /// The change in a value during a time interval.
    case delta // = 2

    /// A value accumulated over a time interval.  Cumulative
    /// measurements in a time series should have the same start time
    /// and increasing end times, until an event resets the cumulative
    /// value to zero and sets a new start time for the following
    /// points.
    case cumulative // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .gauge
      case 2: self = .delta
      case 3: self = .cumulative
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .gauge: return 1
      case .delta: return 2
      case .cumulative: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The value type of a metric.
  public enum ValueType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Do not use this default value.
    case unspecified // = 0

    /// The value is a boolean.
    /// This value type can be used only if the metric kind is `GAUGE`.
    case bool // = 1

    /// The value is a signed 64-bit integer.
    case int64 // = 2

    /// The value is a double precision floating point number.
    case double // = 3

    /// The value is a text string.
    /// This value type can be used only if the metric kind is `GAUGE`.
    case string // = 4

    /// The value is a [`Distribution`][google.api.Distribution].
    case distribution // = 5

    /// The value is money.
    case money // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .bool
      case 2: self = .int64
      case 3: self = .double
      case 4: self = .string
      case 5: self = .distribution
      case 6: self = .money
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .bool: return 1
      case .int64: return 2
      case .double: return 3
      case .string: return 4
      case .distribution: return 5
      case .money: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Api_MetricDescriptor.MetricKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Api_MetricDescriptor.MetricKind] = [
    .unspecified,
    .gauge,
    .delta,
    .cumulative,
  ]
}

extension Google_Api_MetricDescriptor.ValueType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Api_MetricDescriptor.ValueType] = [
    .unspecified,
    .bool,
    .int64,
    .double,
    .string,
    .distribution,
    .money,
  ]
}

#endif  // swift(>=4.2)

/// A specific metric, identified by specifying values for all of the
/// labels of a [`MetricDescriptor`][google.api.MetricDescriptor].
public struct Google_Api_Metric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An existing metric type, see [google.api.MetricDescriptor][google.api.MetricDescriptor].
  /// For example, `custom.googleapis.com/invoice/paid/amount`.
  public var type: String = String()

  /// The set of label values that uniquely identify this metric. All
  /// labels listed in the `MetricDescriptor` must be assigned values.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.api"

extension Google_Api_MetricDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetricDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    8: .same(proto: "type"),
    2: .same(proto: "labels"),
    3: .standard(proto: "metric_kind"),
    4: .standard(proto: "value_type"),
    5: .same(proto: "unit"),
    6: .same(proto: "description"),
    7: .standard(proto: "display_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 3: try decoder.decodeSingularEnumField(value: &self.metricKind)
      case 4: try decoder.decodeSingularEnumField(value: &self.valueType)
      case 5: try decoder.decodeSingularStringField(value: &self.unit)
      case 6: try decoder.decodeSingularStringField(value: &self.description_p)
      case 7: try decoder.decodeSingularStringField(value: &self.displayName)
      case 8: try decoder.decodeSingularStringField(value: &self.type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 2)
    }
    if self.metricKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.metricKind, fieldNumber: 3)
    }
    if self.valueType != .unspecified {
      try visitor.visitSingularEnumField(value: self.valueType, fieldNumber: 4)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 7)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_MetricDescriptor, rhs: Google_Api_MetricDescriptor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.metricKind != rhs.metricKind {return false}
    if lhs.valueType != rhs.valueType {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_MetricDescriptor.MetricKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "METRIC_KIND_UNSPECIFIED"),
    1: .same(proto: "GAUGE"),
    2: .same(proto: "DELTA"),
    3: .same(proto: "CUMULATIVE"),
  ]
}

extension Google_Api_MetricDescriptor.ValueType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VALUE_TYPE_UNSPECIFIED"),
    1: .same(proto: "BOOL"),
    2: .same(proto: "INT64"),
    3: .same(proto: "DOUBLE"),
    4: .same(proto: "STRING"),
    5: .same(proto: "DISTRIBUTION"),
    6: .same(proto: "MONEY"),
  ]
}

extension Google_Api_Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "type"),
    2: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels)
      case 3: try decoder.decodeSingularStringField(value: &self.type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Metric, rhs: Google_Api_Metric) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
