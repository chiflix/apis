// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/api/distribution.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Distribution contains summary statistics for a population of values and,
/// optionally, a histogram representing the distribution of those values across
/// a specified set of histogram buckets.
///
/// The summary statistics are the count, mean, sum of the squared deviation from
/// the mean, the minimum, and the maximum of the set of population of values.
///
/// The histogram is based on a sequence of buckets and gives a count of values
/// that fall into each bucket.  The boundaries of the buckets are given either
/// explicitly or by specifying parameters for a method of computing them
/// (buckets of fixed width or buckets of exponentially increasing width).
///
/// Although it is not forbidden, it is generally a bad idea to include
/// non-finite values (infinities or NaNs) in the population of values, as this
/// will render the `mean` and `sum_of_squared_deviation` fields meaningless.
public struct Google_Api_Distribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of values in the population. Must be non-negative.
  public var count: Int64 {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  /// The arithmetic mean of the values in the population. If `count` is zero
  /// then this field must be zero.
  public var mean: Double {
    get {return _storage._mean}
    set {_uniqueStorage()._mean = newValue}
  }

  /// The sum of squared deviations from the mean of the values in the
  /// population.  For values x_i this is:
  ///
  ///     Sum[i=1..n]((x_i - mean)^2)
  ///
  /// Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
  /// describes Welford's method for accumulating this sum in one pass.
  ///
  /// If `count` is zero then this field must be zero.
  public var sumOfSquaredDeviation: Double {
    get {return _storage._sumOfSquaredDeviation}
    set {_uniqueStorage()._sumOfSquaredDeviation = newValue}
  }

  /// If specified, contains the range of the population values. The field
  /// must not be present if the `count` is zero.
  public var range: Google_Api_Distribution.Range {
    get {return _storage._range ?? Google_Api_Distribution.Range()}
    set {_uniqueStorage()._range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  public var hasRange: Bool {return _storage._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  public mutating func clearRange() {_uniqueStorage()._range = nil}

  /// Defines the histogram bucket boundaries.
  public var bucketOptions: Google_Api_Distribution.BucketOptions {
    get {return _storage._bucketOptions ?? Google_Api_Distribution.BucketOptions()}
    set {_uniqueStorage()._bucketOptions = newValue}
  }
  /// Returns true if `bucketOptions` has been explicitly set.
  public var hasBucketOptions: Bool {return _storage._bucketOptions != nil}
  /// Clears the value of `bucketOptions`. Subsequent reads from it will return its default value.
  public mutating func clearBucketOptions() {_uniqueStorage()._bucketOptions = nil}

  /// If `bucket_options` is given, then the sum of the values in `bucket_counts`
  /// must equal the value in `count`.  If `bucket_options` is not given, no
  /// `bucket_counts` fields may be given.
  ///
  /// Bucket counts are given in order under the numbering scheme described
  /// above (the underflow bucket has number 0; the finite buckets, if any,
  /// have numbers 1 through N-2; the overflow bucket has number N-1).
  ///
  /// The size of `bucket_counts` must be no greater than N as defined in
  /// `bucket_options`.
  ///
  /// Any suffix of trailing zero bucket_count fields may be omitted.
  public var bucketCounts: [Int64] {
    get {return _storage._bucketCounts}
    set {_uniqueStorage()._bucketCounts = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The range of the population values.
  public struct Range {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The minimum of the population values.
    public var min: Double = 0

    /// The maximum of the population values.
    public var max: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A Distribution may optionally contain a histogram of the values in the
  /// population.  The histogram is given in `bucket_counts` as counts of values
  /// that fall into one of a sequence of non-overlapping buckets.  The sequence
  /// of buckets is described by `bucket_options`.
  ///
  /// A bucket specifies an inclusive lower bound and exclusive upper bound for
  /// the values that are counted for that bucket.  The upper bound of a bucket
  /// is strictly greater than the lower bound.
  ///
  /// The sequence of N buckets for a Distribution consists of an underflow
  /// bucket (number 0), zero or more finite buckets (number 1 through N - 2) and
  /// an overflow bucket (number N - 1).  The buckets are contiguous:  the lower
  /// bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1.
  /// The buckets span the whole range of finite values: lower bound of the
  /// underflow bucket is -infinity and the upper bound of the overflow bucket is
  /// +infinity.  The finite buckets are so-called because both bounds are
  /// finite.
  ///
  /// `BucketOptions` describes bucket boundaries in one of three ways.  Two
  /// describe the boundaries by giving parameters for a formula to generate
  /// boundaries and one gives the bucket boundaries explicitly.
  ///
  /// If `bucket_boundaries` is not given, then no `bucket_counts` may be given.
  public struct BucketOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Exactly one of these three fields must be set.
    public var options: OneOf_Options? {
      get {return _storage._options}
      set {_uniqueStorage()._options = newValue}
    }

    /// The linear bucket.
    public var linearBuckets: Google_Api_Distribution.BucketOptions.Linear {
      get {
        if case .linearBuckets(let v)? = _storage._options {return v}
        return Google_Api_Distribution.BucketOptions.Linear()
      }
      set {_uniqueStorage()._options = .linearBuckets(newValue)}
    }

    /// The exponential buckets.
    public var exponentialBuckets: Google_Api_Distribution.BucketOptions.Exponential {
      get {
        if case .exponentialBuckets(let v)? = _storage._options {return v}
        return Google_Api_Distribution.BucketOptions.Exponential()
      }
      set {_uniqueStorage()._options = .exponentialBuckets(newValue)}
    }

    /// The explicit buckets.
    public var explicitBuckets: Google_Api_Distribution.BucketOptions.Explicit {
      get {
        if case .explicitBuckets(let v)? = _storage._options {return v}
        return Google_Api_Distribution.BucketOptions.Explicit()
      }
      set {_uniqueStorage()._options = .explicitBuckets(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Exactly one of these three fields must be set.
    public enum OneOf_Options: Equatable {
      /// The linear bucket.
      case linearBuckets(Google_Api_Distribution.BucketOptions.Linear)
      /// The exponential buckets.
      case exponentialBuckets(Google_Api_Distribution.BucketOptions.Exponential)
      /// The explicit buckets.
      case explicitBuckets(Google_Api_Distribution.BucketOptions.Explicit)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Api_Distribution.BucketOptions.OneOf_Options, rhs: Google_Api_Distribution.BucketOptions.OneOf_Options) -> Bool {
        switch (lhs, rhs) {
        case (.linearBuckets(let l), .linearBuckets(let r)): return l == r
        case (.exponentialBuckets(let l), .exponentialBuckets(let r)): return l == r
        case (.explicitBuckets(let l), .explicitBuckets(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    /// Specify a sequence of buckets that all have the same width (except
    /// overflow and underflow).  Each bucket represents a constant absolute
    /// uncertainty on the specific value in the bucket.
    ///
    /// Defines `num_finite_buckets + 2` (= N) buckets with these boundaries for
    /// bucket `i`:
    ///
    ///    Upper bound (0 <= i < N-1):     offset + (width * i).
    ///    Lower bound (1 <= i < N):       offset + (width * (i - 1)).
    public struct Linear {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Must be greater than 0.
      public var numFiniteBuckets: Int32 = 0

      /// Must be greater than 0.
      public var width: Double = 0

      /// Lower bound of the first bucket.
      public var offset: Double = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Specify a sequence of buckets that have a width that is proportional to
    /// the value of the lower bound.  Each bucket represents a constant relative
    /// uncertainty on a specific value in the bucket.
    ///
    /// Defines `num_finite_buckets + 2` (= N) buckets with these boundaries for
    /// bucket i:
    ///
    ///    Upper bound (0 <= i < N-1):     scale * (growth_factor ^ i).
    ///    Lower bound (1 <= i < N):       scale * (growth_factor ^ (i - 1)).
    public struct Exponential {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Must be greater than 0.
      public var numFiniteBuckets: Int32 = 0

      /// Must be greater than 1.
      public var growthFactor: Double = 0

      /// Must be greater than 0.
      public var scale: Double = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// A set of buckets with arbitrary widths.
    ///
    /// Defines `size(bounds) + 1` (= N) buckets with these boundaries for
    /// bucket i:
    ///
    ///    Upper bound (0 <= i < N-1):     bounds[i]
    ///    Lower bound (1 <= i < N);       bounds[i - 1]
    ///
    /// There must be at least one element in `bounds`.  If `bounds` has only one
    /// element, there are no finite buckets, and that single element is the
    /// common boundary of the overflow and underflow buckets.
    public struct Explicit {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The values must be monotonically increasing.
      public var bounds: [Double] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.api"

extension Google_Api_Distribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Distribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "mean"),
    3: .standard(proto: "sum_of_squared_deviation"),
    4: .same(proto: "range"),
    6: .standard(proto: "bucket_options"),
    7: .standard(proto: "bucket_counts"),
  ]

  fileprivate class _StorageClass {
    var _count: Int64 = 0
    var _mean: Double = 0
    var _sumOfSquaredDeviation: Double = 0
    var _range: Google_Api_Distribution.Range? = nil
    var _bucketOptions: Google_Api_Distribution.BucketOptions? = nil
    var _bucketCounts: [Int64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _count = source._count
      _mean = source._mean
      _sumOfSquaredDeviation = source._sumOfSquaredDeviation
      _range = source._range
      _bucketOptions = source._bucketOptions
      _bucketCounts = source._bucketCounts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._count)
        case 2: try decoder.decodeSingularDoubleField(value: &_storage._mean)
        case 3: try decoder.decodeSingularDoubleField(value: &_storage._sumOfSquaredDeviation)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._range)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._bucketOptions)
        case 7: try decoder.decodeRepeatedInt64Field(value: &_storage._bucketCounts)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._count != 0 {
        try visitor.visitSingularInt64Field(value: _storage._count, fieldNumber: 1)
      }
      if _storage._mean != 0 {
        try visitor.visitSingularDoubleField(value: _storage._mean, fieldNumber: 2)
      }
      if _storage._sumOfSquaredDeviation != 0 {
        try visitor.visitSingularDoubleField(value: _storage._sumOfSquaredDeviation, fieldNumber: 3)
      }
      if let v = _storage._range {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._bucketOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._bucketCounts.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._bucketCounts, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Distribution, rhs: Google_Api_Distribution) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._count != rhs_storage._count {return false}
        if _storage._mean != rhs_storage._mean {return false}
        if _storage._sumOfSquaredDeviation != rhs_storage._sumOfSquaredDeviation {return false}
        if _storage._range != rhs_storage._range {return false}
        if _storage._bucketOptions != rhs_storage._bucketOptions {return false}
        if _storage._bucketCounts != rhs_storage._bucketCounts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Distribution.Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Distribution.protoMessageName + ".Range"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.min)
      case 2: try decoder.decodeSingularDoubleField(value: &self.max)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min != 0 {
      try visitor.visitSingularDoubleField(value: self.min, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularDoubleField(value: self.max, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Distribution.Range, rhs: Google_Api_Distribution.Range) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Distribution.BucketOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Distribution.protoMessageName + ".BucketOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "linear_buckets"),
    2: .standard(proto: "exponential_buckets"),
    3: .standard(proto: "explicit_buckets"),
  ]

  fileprivate class _StorageClass {
    var _options: Google_Api_Distribution.BucketOptions.OneOf_Options?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _options = source._options
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Google_Api_Distribution.BucketOptions.Linear?
          if let current = _storage._options {
            try decoder.handleConflictingOneOf()
            if case .linearBuckets(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._options = .linearBuckets(v)}
        case 2:
          var v: Google_Api_Distribution.BucketOptions.Exponential?
          if let current = _storage._options {
            try decoder.handleConflictingOneOf()
            if case .exponentialBuckets(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._options = .exponentialBuckets(v)}
        case 3:
          var v: Google_Api_Distribution.BucketOptions.Explicit?
          if let current = _storage._options {
            try decoder.handleConflictingOneOf()
            if case .explicitBuckets(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._options = .explicitBuckets(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._options {
      case .linearBuckets(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .exponentialBuckets(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .explicitBuckets(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Distribution.BucketOptions, rhs: Google_Api_Distribution.BucketOptions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._options != rhs_storage._options {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Distribution.BucketOptions.Linear: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Distribution.BucketOptions.protoMessageName + ".Linear"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_finite_buckets"),
    2: .same(proto: "width"),
    3: .same(proto: "offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.numFiniteBuckets)
      case 2: try decoder.decodeSingularDoubleField(value: &self.width)
      case 3: try decoder.decodeSingularDoubleField(value: &self.offset)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numFiniteBuckets != 0 {
      try visitor.visitSingularInt32Field(value: self.numFiniteBuckets, fieldNumber: 1)
    }
    if self.width != 0 {
      try visitor.visitSingularDoubleField(value: self.width, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularDoubleField(value: self.offset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Distribution.BucketOptions.Linear, rhs: Google_Api_Distribution.BucketOptions.Linear) -> Bool {
    if lhs.numFiniteBuckets != rhs.numFiniteBuckets {return false}
    if lhs.width != rhs.width {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Distribution.BucketOptions.Exponential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Distribution.BucketOptions.protoMessageName + ".Exponential"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_finite_buckets"),
    2: .standard(proto: "growth_factor"),
    3: .same(proto: "scale"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.numFiniteBuckets)
      case 2: try decoder.decodeSingularDoubleField(value: &self.growthFactor)
      case 3: try decoder.decodeSingularDoubleField(value: &self.scale)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numFiniteBuckets != 0 {
      try visitor.visitSingularInt32Field(value: self.numFiniteBuckets, fieldNumber: 1)
    }
    if self.growthFactor != 0 {
      try visitor.visitSingularDoubleField(value: self.growthFactor, fieldNumber: 2)
    }
    if self.scale != 0 {
      try visitor.visitSingularDoubleField(value: self.scale, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Distribution.BucketOptions.Exponential, rhs: Google_Api_Distribution.BucketOptions.Exponential) -> Bool {
    if lhs.numFiniteBuckets != rhs.numFiniteBuckets {return false}
    if lhs.growthFactor != rhs.growthFactor {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Distribution.BucketOptions.Explicit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Distribution.BucketOptions.protoMessageName + ".Explicit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bounds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedDoubleField(value: &self.bounds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bounds.isEmpty {
      try visitor.visitPackedDoubleField(value: self.bounds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Distribution.BucketOptions.Explicit, rhs: Google_Api_Distribution.BucketOptions.Explicit) -> Bool {
    if lhs.bounds != rhs.bounds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
