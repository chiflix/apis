// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: training/v1/training.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 Sagittarius LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Sagittarius_Training_V1_TrainingData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the media identity
  public var mediaIdentity: String = String()

  /// the language code of the payload
  /// ISO-639-1/bcp47 Code with tags
  /// https://cloud.google.com/translate/docs/languages
  public var languageCode: String = String()

  /// the format of the payload
  public var format: String = String()

  /// how long does this transcript been played
  public var playedTime: Double = 0

  /// how long of the entire video
  public var totalTime: Double = 0

  /// in ms, can be +/-
  public var delay: Int64 = 0

  /// hints or keywords related to this media
  public var hints: String = String()

  public var data: Sagittarius_Training_V1_TrainingData.OneOf_Data? = nil

  /// transcript identity if any
  public var transcriptIdentity: String {
    get {
      if case .transcriptIdentity(let v)? = data {return v}
      return String()
    }
    set {data = .transcriptIdentity(newValue)}
  }

  /// the transcripts payload
  public var payload: Data {
    get {
      if case .payload(let v)? = data {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {data = .payload(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable {
    /// transcript identity if any
    case transcriptIdentity(String)
    /// the transcripts payload
    case payload(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Sagittarius_Training_V1_TrainingData.OneOf_Data, rhs: Sagittarius_Training_V1_TrainingData.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.transcriptIdentity(let l), .transcriptIdentity(let r)): return l == r
      case (.payload(let l), .payload(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// TODO:
public struct Sagittarius_Training_V1_StreamingTrainingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The streaming request, which is either a streaming config or audio content.
  public var streamingRequest: OneOf_StreamingRequest? {
    get {return _storage._streamingRequest}
    set {_uniqueStorage()._streamingRequest = newValue}
  }

  /// Provides information to the recognizer that specifies how to process the
  /// request. The first `StreamingTranslationRequest` message must contain a
  /// `streaming_config`  message.
  public var streamingConfig: Google_Cloud_Speech_V1_RecognitionConfig {
    get {
      if case .streamingConfig(let v)? = _storage._streamingRequest {return v}
      return Google_Cloud_Speech_V1_RecognitionConfig()
    }
    set {_uniqueStorage()._streamingRequest = .streamingConfig(newValue)}
  }

  /// The audio data to be trained. Sequential chunks of audio data are sent
  /// in sequential `StreamingTranslationRequest` messages. The first
  /// `StreamingTranslationRequest` message must not contain `audio_content` data
  /// and all subsequent `StreamingTranslationRequest` messages must contain
  /// `audio_content` data. The audio bytes must be encoded as specified in
  /// `RecognitionConfig`. Note: as with all bytes fields, protobuffers use a
  /// pure binary representation (not base64). See
  /// [audio limits](https://cloud.google.com/speech/limits#content).
  public var audioContent: Data {
    get {
      if case .audioContent(let v)? = _storage._streamingRequest {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._streamingRequest = .audioContent(newValue)}
  }

  public var transcript: String {
    get {return _storage._transcript}
    set {_uniqueStorage()._transcript = newValue}
  }

  /// the media identity
  public var mediaIdentity: String {
    get {return _storage._mediaIdentity}
    set {_uniqueStorage()._mediaIdentity = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The streaming request, which is either a streaming config or audio content.
  public enum OneOf_StreamingRequest: Equatable {
    /// Provides information to the recognizer that specifies how to process the
    /// request. The first `StreamingTranslationRequest` message must contain a
    /// `streaming_config`  message.
    case streamingConfig(Google_Cloud_Speech_V1_RecognitionConfig)
    /// The audio data to be trained. Sequential chunks of audio data are sent
    /// in sequential `StreamingTranslationRequest` messages. The first
    /// `StreamingTranslationRequest` message must not contain `audio_content` data
    /// and all subsequent `StreamingTranslationRequest` messages must contain
    /// `audio_content` data. The audio bytes must be encoded as specified in
    /// `RecognitionConfig`. Note: as with all bytes fields, protobuffers use a
    /// pure binary representation (not base64). See
    /// [audio limits](https://cloud.google.com/speech/limits#content).
    case audioContent(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Sagittarius_Training_V1_StreamingTrainingRequest.OneOf_StreamingRequest, rhs: Sagittarius_Training_V1_StreamingTrainingRequest.OneOf_StreamingRequest) -> Bool {
      switch (lhs, rhs) {
      case (.streamingConfig(let l), .streamingConfig(let r)): return l == r
      case (.audioContent(let l), .audioContent(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sagittarius.training.v1"

extension Sagittarius_Training_V1_TrainingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrainingData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "media_identity"),
    2: .standard(proto: "language_code"),
    4: .same(proto: "format"),
    5: .standard(proto: "played_time"),
    6: .standard(proto: "total_time"),
    8: .same(proto: "delay"),
    9: .same(proto: "hints"),
    3: .standard(proto: "transcript_identity"),
    7: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.mediaIdentity)
      case 2: try decoder.decodeSingularStringField(value: &self.languageCode)
      case 3:
        if self.data != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.data = .transcriptIdentity(v)}
      case 4: try decoder.decodeSingularStringField(value: &self.format)
      case 5: try decoder.decodeSingularDoubleField(value: &self.playedTime)
      case 6: try decoder.decodeSingularDoubleField(value: &self.totalTime)
      case 7:
        if self.data != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.data = .payload(v)}
      case 8: try decoder.decodeSingularInt64Field(value: &self.delay)
      case 9: try decoder.decodeSingularStringField(value: &self.hints)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mediaIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaIdentity, fieldNumber: 1)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 2)
    }
    if case .transcriptIdentity(let v)? = self.data {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 4)
    }
    if self.playedTime != 0 {
      try visitor.visitSingularDoubleField(value: self.playedTime, fieldNumber: 5)
    }
    if self.totalTime != 0 {
      try visitor.visitSingularDoubleField(value: self.totalTime, fieldNumber: 6)
    }
    if case .payload(let v)? = self.data {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    }
    if self.delay != 0 {
      try visitor.visitSingularInt64Field(value: self.delay, fieldNumber: 8)
    }
    if !self.hints.isEmpty {
      try visitor.visitSingularStringField(value: self.hints, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sagittarius_Training_V1_TrainingData, rhs: Sagittarius_Training_V1_TrainingData) -> Bool {
    if lhs.mediaIdentity != rhs.mediaIdentity {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.format != rhs.format {return false}
    if lhs.playedTime != rhs.playedTime {return false}
    if lhs.totalTime != rhs.totalTime {return false}
    if lhs.delay != rhs.delay {return false}
    if lhs.hints != rhs.hints {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sagittarius_Training_V1_StreamingTrainingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamingTrainingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "streaming_config"),
    2: .standard(proto: "audio_content"),
    3: .same(proto: "transcript"),
    4: .standard(proto: "media_identity"),
  ]

  fileprivate class _StorageClass {
    var _streamingRequest: Sagittarius_Training_V1_StreamingTrainingRequest.OneOf_StreamingRequest?
    var _transcript: String = String()
    var _mediaIdentity: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _streamingRequest = source._streamingRequest
      _transcript = source._transcript
      _mediaIdentity = source._mediaIdentity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Google_Cloud_Speech_V1_RecognitionConfig?
          if let current = _storage._streamingRequest {
            try decoder.handleConflictingOneOf()
            if case .streamingConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._streamingRequest = .streamingConfig(v)}
        case 2:
          if _storage._streamingRequest != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._streamingRequest = .audioContent(v)}
        case 3: try decoder.decodeSingularStringField(value: &_storage._transcript)
        case 4: try decoder.decodeSingularStringField(value: &_storage._mediaIdentity)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._streamingRequest {
      case .streamingConfig(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .audioContent(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      case nil: break
      }
      if !_storage._transcript.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transcript, fieldNumber: 3)
      }
      if !_storage._mediaIdentity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mediaIdentity, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sagittarius_Training_V1_StreamingTrainingRequest, rhs: Sagittarius_Training_V1_StreamingTrainingRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._streamingRequest != rhs_storage._streamingRequest {return false}
        if _storage._transcript != rhs_storage._transcript {return false}
        if _storage._mediaIdentity != rhs_storage._mediaIdentity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
